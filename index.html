<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Missing Digit — 12 Marks (Add & Sub) • Persisted + New-Session Reset + SLS</title>

<!-- Activity ID (yours) -->
<script>
  window.ACTIVITY_ID = "https://limkimsze-maker.github.io/Add_Sub_Missing_Digit_ActID/";
</script>

<!-- xAPI base scripts (same as your working file expects) -->
<script src="xapiwrapper.min.js"></script>
<script src="index.js" defer></script>

<!-- New-Session Clear Kit -->
<script>
(function (global){
  const Kit = {
    init(opts = {}) {
      const ACTIVITY_ID = String(opts.activityId || global.ACTIVITY_ID || location.href);
      const QS = new URLSearchParams(location.search);
      const salt = (typeof opts.scopeSalt === 'function') ? (opts.scopeSalt(QS) || '') : (opts.scopeSalt || '');
      const baseQS = QS.get('attempt') || QS.get('run') || QS.get('session') || QS.toString() || 'noqs';
      const CURR_SCOPE = `${ACTIVITY_ID}::${salt}::${baseQS}`;
      const SCOPE_KEY  = `sls_scope::${ACTIVITY_ID}`;
      const resetParam = opts.resetParam || 'reset';
      const FORCE = QS.has(resetParam) || QS.has('newSession');

      let prev = null;
      try { prev = localStorage.getItem(SCOPE_KEY); } catch (e) {}

      const isNew = FORCE || prev !== CURR_SCOPE;
      if (isNew) {
        if (opts.clickButtonId) {
          const btn = document.getElementById(opts.clickButtonId);
          if (btn) {
            try { btn.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true })); } catch (e) {}
          }
        }
        if (typeof opts.onNewSession === 'function') {
          try { opts.onNewSession(); } catch (e) {}
        }
        if (opts.pushZero !== false) {
          const payload = { score: 0 };
          try { if (typeof global.storeState === 'function') global.storeState(payload); } catch (e) {}
          try { if (typeof global.sendState  === 'function') global.sendState(payload);  } catch (e) {}
        }
        try { localStorage.setItem(SCOPE_KEY, CURR_SCOPE); } catch (e) {}
      }
      return { isNewAssignment: isNew, scope: CURR_SCOPE };
    }
  };
  global.NewSessionClearKit = Kit;
})(window);
</script>

<style>
  :root{
    --ink:#0f172a; --muted:#64748b; --ok:#16a34a; --bad:#dc2626; --line:#0f172a;
    --bg:#fafafa; --panel:#ffffff; --accent:#2563eb; --hint:#f8fafc; --hl:#fde68a;
    --shadow: 0 10px 30px rgba(2,6,23,.08);
  }
  html,body{margin:0;background:var(--bg);font-family:system-ui,Segoe UI,Arial;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
  *{-webkit-tap-highlight-color: transparent}
  .page{max-width:980px;margin:20px auto;padding:0 14px}
  .topbar{display:flex;flex-wrap:wrap;gap:10px;justify-content:space-between;align-items:center;margin:8px 0 14px}
  .title{font-size:22px;color:var(--ink);font-weight:700}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .score{background:var(--panel);border:1px solid #e2e8f0;border-radius:12px;padding:8px 12px;font-weight:700;box-shadow:var(--shadow)}
  button.ctrl{border:1px solid #e2e8f0;background:#fff;border-radius:10px;padding:8px 12px;font-weight:700;cursor:pointer}
  .lockstate{font-size:12px;color:#111827;background:#e2e8f0;border-radius:999px;padding:2px 8px}
  .unlocked{background:#dcfce7}
  .locked{background:#fde68a}
  .meta{font-size:12px;color:var(--muted)}
  .badge{display:none;background:#0f172a;color:#fff;padding:6px 10px;border-radius:10px;font-size:12px;white-space:nowrap;max-width:60ch;overflow:hidden;text-overflow:ellipsis}

  h2{font-size:18px;margin:18px 0 10px;color:var(--ink)}
  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:14px}
  .qcard{background:var(--panel);border:1px solid #e2e8f0;border-radius:16px;padding:12px;box-shadow:var(--shadow);display:flex;flex-direction:column;gap:10px}
  .header{display:flex;justify-content:space-between;align-items:center}
  .qno{font-weight:800;color:#111827}
  .tag{font-size:12px;color:#334155;background:#e2e8f0;border-radius:999px;padding:2px 8px}

  .sum{font-variant-numeric:tabular-nums;display:inline-block;padding:8px 12px;border-radius:12px;border:1px dashed #e5e7eb;background:#fff}
  .row{display:flex;align-items:flex-end;justify-content:flex-end;gap:8px}
  .row + .row{margin-top:4px}
  .digits{display:grid;grid-auto-flow:column;gap:8px}
  .digit,.box{width:32px;height:40px;display:flex;align-items:center;justify-content:center;font-size:26px;color:var(--ink)}
  .prefix{width:22px;text-align:center;font-size:20px;color:#475569}
  .hr{height:2px;background:var(--line);margin:6px 0 4px;border-radius:2px}

  input.box{text-align:center;border:2px solid #0f172a;border-radius:8px;font-size:26px;width:38px;height:42px;outline:none}
  input.box.correct{border-color:var(--ok);background:#ecfdf5}
  input.box.wrong{border-color:var(--bad);background:#fef2f2}

  .actions{display:flex;gap:8px;flex-wrap:wrap}
  button{border:1px solid #e2e8f0;background:#fff;border-radius:10px;padding:8px 12px;cursor:pointer;font-weight:700;color:#0f172a}
  button.primary{background:var(--accent);border-color:var(--accent);color:#fff}
  button:disabled{opacity:.6;cursor:not-allowed}
  button:active{transform:translateY(1px)}
  .status{min-height:20px;font-weight:700}
  .ok{color:var(--ok)} .bad{color:var(--bad)} .muted{color:var(--muted)}

  .guide{background:var(--hint);border:1px solid #e2e8f0;border-radius:12px;padding:10px}
  .mini{font-variant-numeric:tabular-nums;display:inline-block;background:#fff;border:1px solid #e5e7eb;border-radius:10px;padding:8px}
  .mini .row .digit{font-size:20px;width:26px;height:32px}
  .mini .prefix{width:18px;font-size:18px}
  .mini .hl{background:var(--hl);border-radius:6px;padding:1px 4px}

  footer{max-width:980px;margin:16px auto 28px;padding:0 14px}
  .credit{font-size:12px;color:#475569;background:#eef2ff;border:1px solid #c7d2fe;border-radius:10px;padding:8px 12px;text-align:center}

  /* Tiny “Saved to SLS” panel — layer promoted to avoid mobile flicker */
  #slsMini{
    position:fixed; right:10px; bottom:10px; z-index:40;
    background:#fff;border:1px solid #e2e8f0;border-radius:12px;padding:10px 12px;
    box-shadow:0 8px 24px rgba(0,0,0,.12); font:12px/1.3 system-ui; display:none;
    max-width:60ch;
    transform:translateZ(0);
    will-change: transform;
    -webkit-backface-visibility:hidden;
    contain: paint;
  }
  #slsMini strong{font-size:12px}
</style>
</head>
<body>

<!-- ===== Hidden xAPI base: FULL rubric block restored ===== -->
<div id="xapiBase" style="display:none">
  <p class="center"><strong>HTML5 Interactive</strong></p>
  <div class="center">
    <label for="score-input">Score:</label>
    <input type="text" id="score-input" />
    <label for="feedback-input">Feedback:</label>
    <input type="text" id="feedback-input" placeholder="Enter feedback" />
  </div>
  <div id="criteria-container" class="center"></div>
  <div class="center">
    <button id="add-criteria-button">Add Rubric Criteria</button>
  </div>
  <div class="center">
    <button id="save-store">Send/Save</button>
    <button id="clear-inputs">Clear</button>
  </div>
  <div class="output-container">
    <pre id="result"></pre>
    <hr class="separator" />
    <pre id="getState"></pre>
    <hr class="separator" />
    <pre id="questionId"></pre>
    <pre id="userId"></pre>
    <pre id="cookieId"></pre>
    <a id="activityLink" href="https://limkimsze-maker.github.io/Add_Sub_Missing_Digit_ActID/" target="_blank" rel="noopener">ActivityID</a>
  </div>
</div>
<!-- ===== /xAPI base ===== -->

<div class="page">
  <div class="topbar">
    <div class="title">Missing Digit Quiz — 12 Questions (1 mark each)</div>
    <div class="controls">
      <span id="lockState" class="lockstate locked" title="Default: guides unlock only after first wrong attempt.">Guides Locked (until wrong)</span>
      <button id="btnUnlock" class="ctrl" title="Teacher: enter password to allow guides anytime">Unlock Guides (Teacher)</button>
      <button id="btnRelock" class="ctrl" title="Return to locked-until-wrong mode" disabled>Re-lock Guides</button>
      <div id="score" class="score">Score: 0 / 12</div>
      <button id="newSessionBtn" class="ctrl" title="Start a brand-new session (clears saved state)">New session</button>
      <span id="statusBadge" class="badge" aria-live="polite">—</span>
    </div>
  </div>

  <h2>Part A — Addition (6 questions)</h2>
  <div id="partA" class="grid"></div>

  <h2>Part B — Subtraction (6 questions)</h2>
  <div id="partB" class="grid"></div>

  <p class="meta">Guides are hidden by default. In locked mode, pupils can see a guide only after their first wrong attempt on that question. Teacher can unlock with password <strong>0000</strong>. After finishing, return to SLS and click <em>Submit</em> to record your score.</p>
</div>

<footer>
  <div class="credit">© 2025 <strong>Lim Kim Sze</strong>. All rights reserved.</div>
</footer>

<!-- Saved-to-SLS mini panel -->
<div id="slsMini"><strong>Saved to SLS</strong><div id="slsMiniLine">—</div></div>

<script>
(() => {
  /* ========= xAPI / SLS compatibility layer ========= */
  const MDQ_TOTAL = 12;
  const PAYLOAD_KEY = 'mdq_payload_v3'; // compact score/feedback

  // Debounce first-paint updates to avoid load-time flicker
  let BOOTING = true;

  function pushToXAPI(rawScore, feedback=''){
    if (BOOTING) return;
    try {
      const sInput = document.getElementById('score-input');
      const fInput = document.getElementById('feedback-input');
      if (sInput) sInput.value = String(rawScore);
      if (fInput) fInput.value = String(feedback || '');

      let saved = false;
      try { if (typeof updateStore === 'function') { updateStore(); saved = true; } } catch(e){}
      try { if (!saved && typeof storeState === 'function') { storeState({ score: rawScore, feedback }); saved = true; } } catch(e){}
      try { if (!saved && typeof sendState  === 'function') { sendState({ score: rawScore, feedback });  saved = true; } } catch(e){}

      if (!saved) {
        const btn = document.getElementById('save-store');
        if (btn) { try { btn.click(); saved = true; } catch(e){} }
      }

      const badge = document.getElementById('statusBadge');
      if (badge) {
        badge.style.display = 'inline-block';
        const percent = Math.round((rawScore/MDQ_TOTAL)*100);
        const fb = feedback ? (feedback.length>40 ? feedback.slice(0,40)+'…' : feedback) : '';
        badge.textContent = `Saved for SLS · ${rawScore}/${MDQ_TOTAL} (${percent}%)${fb ? ' · ' + fb : ''}`;
      }
      const mini = document.getElementById('slsMini');
      const line = document.getElementById('slsMiniLine');
      if (mini && line) {
        mini.style.display = 'block';
        const percent = Math.round((rawScore/MDQ_TOTAL)*100);
        line.textContent = `Score ${rawScore}/${MDQ_TOTAL} (${percent}%)${feedback ? ' — ' + (feedback.slice(0,60)+(feedback.length>60?'…':'')) : ''}`;
      }
    } catch(e) {}
  }

  function writePayload(score, feedback){
    try { localStorage.setItem(PAYLOAD_KEY, JSON.stringify({ score, feedback, t: Date.now() })); } catch(e){}
  }
  function readPayload(){ try { const raw = localStorage.getItem(PAYLOAD_KEY); return raw ? JSON.parse(raw) : null; } catch(e){ return null; } }
  function syncFromLocalStorageToXAPI(){ const p = readPayload(); if (!p) return; pushToXAPI(p.score, p.feedback); }
  window.addEventListener('load', syncFromLocalStorageToXAPI, { once:true });
  window.addEventListener('visibilitychange', ()=>{ if (!document.hidden) syncFromLocalStorageToXAPI(); });
  window.addEventListener('focus', syncFromLocalStorageToXAPI);
  window.addEventListener('storage', (e)=>{ if (e.key === PAYLOAD_KEY && e.newValue) syncFromLocalStorageToXAPI(); });

  /* ========= Worksheet generator ========= */
  const STATE_KEY   = 'mdq_state_v3';

  const rint = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
  const toDigits = (n,w=4)=>String(n).padStart(w,'0').split('').map(d=>+d);

  function makeAdd_boxA(){
    const S = rint(3000,9999);
    const B = rint(1000, S-1000);
    const A = S - B;
    return {mode:'add', box:'A', A,B,S, hideIdx:rint(0,3)};
  }
  function makeAdd_boxB(){
    const S = rint(3000,9999);
    const A = rint(1000, S-1000);
    const B = S - A;
    return {mode:'add', box:'B', A,B,S, hideIdx:rint(0,3)};
  }
  function makeAdd_boxS(){
    const A = rint(1000, 8999);
    const B = rint(1000, 9999 - A);
    const S = A + B;
    return {mode:'add', box:'S', A,B,S, hideIdx:rint(0,3)};
  }
  function makeSub_boxA(){ // missing in minuend
    const B = rint(1000, 8999);
    const C = rint(0, 9999 - B);
    const A = B + C;
    return {mode:'sub', box:'A', A,B,C, hideIdx:rint(0,3)};
  }
  function makeSub_boxB(){ // missing in subtrahend
    const A = rint(2000, 9999);
    const C = rint(0, A - 1000);
    const B = A - C;
    return {mode:'sub', box:'B', A,B,C, hideIdx:rint(0,3)};
  }
  function makeSub_boxC(){ // missing in difference
    const A = rint(2000, 9999);
    const B = rint(1000, A);
    const C = A - B;
    return {mode:'sub', box:'C', A,B,C, hideIdx:rint(0,3)};
  }
  function computeHiddenDigit(q){
    const dA = toDigits(q.A), dB = toDigits(q.B), dS = toDigits(q.mode==='add'?q.S:q.C);
    return q.box==='A' ? dA[q.hideIdx] : q.box==='B' ? dB[q.hideIdx] : dS[q.hideIdx];
  }

  const partA = document.getElementById('partA');
  const partB = document.getElementById('partB');
  const scoreEl = document.getElementById('score');

  const lockStateEl = document.getElementById('lockState');
  const btnUnlock = document.getElementById('btnUnlock');
  const btnRelock = document.getElementById('btnRelock');

  let WORK = null; // { questions:[...], policy:'locked'|'always' }
  let QDOM = [];   // ui refs per question

  function defaultWorksheet(){
    const Aqs = [
      makeAdd_boxA(), makeAdd_boxA(),
      makeAdd_boxB(), makeAdd_boxB(),
      makeAdd_boxS(), makeAdd_boxS()
    ];
    const Bqs = [
      makeSub_boxA(), makeSub_boxA(),
      makeSub_boxB(), makeSub_boxB(),
      makeSub_boxC(), makeSub_boxC()
    ];
    const qs = [...Aqs, ...Bqs].map((q, idx)=>({
      ...q,
      id: idx+1,
      hiddenDigit: computeHiddenDigit(q),
      value: '',
      mark: 0,
      locked: false,
      wrongOnce: false
    }));
    return { questions: qs, policy: 'locked' };
  }

  function saveState(){
    try { localStorage.setItem(STATE_KEY, JSON.stringify(WORK)); } catch(e){}
    updateScoreAndPush();
  }
  function loadState(){
    try {
      const raw = localStorage.getItem(STATE_KEY);
      if(!raw) return null;
      const parsed = JSON.parse(raw);
      parsed.questions.forEach(q=>{ if(typeof q.hiddenDigit!=='number') q.hiddenDigit = computeHiddenDigit(q); });
      return parsed;
    } catch(e){ return null; }
  }
  window.addEventListener('storage', (e)=>{
    if(e.key === STATE_KEY && e.newValue){
      try { WORK = JSON.parse(e.newValue); rehydrateUIFromState(); } catch(_){}
    }
  });

  function el(tag, attrs={}, ...children){
    const x = document.createElement(tag);
    Object.entries(attrs).forEach(([k,v])=>{
      if(k==='class') x.className=v;
      else if(k==='html') x.innerHTML=v;
      else if(k.startsWith('on') && typeof v==='function') x.addEventListener(k.slice(2), v);
      else x.setAttribute(k,v);
    });
    children.forEach(c=> x.appendChild(c instanceof Node ? c : document.createTextNode(c)));
    return x;
  }

  function digitsRow(prefix, arr, hideIdx, whichBox, which, qIndex){
    const row = el('div',{class:'row'});
    row.appendChild(el('div',{class:'prefix'}, prefix));
    const digits = el('div',{class:'digits'});
    arr.forEach((d,i)=>{
      if(which===whichBox && i===hideIdx){
        const input = el('input',{class:'box', type:'text', inputmode:'numeric', maxlength:'1', placeholder:'□'});
        input.value = WORK.questions[qIndex].value || '';
        digits.appendChild(input);
        QDOM[qIndex]._pendingInput = input;
      }else{
        digits.appendChild(el('div',{class:'digit'}, d));
      }
    });
    row.appendChild(digits);
    return row;
  }

  function verticalBlock(q, qIndex){
    const wrap = el('div',{class:'sum'});
    const aD = toDigits(q.A), bD = toDigits(q.B), sD = toDigits(q.mode==='add'?q.S:q.C);
    wrap.appendChild(digitsRow('', aD, q.hideIdx, q.box, 'A', qIndex));
    wrap.appendChild(digitsRow(q.mode==='add'?'+':'−', bD, q.hideIdx, q.box, 'B', qIndex));
    wrap.appendChild(el('div',{class:'hr'}));
    wrap.appendChild(digitsRow('', sD, q.hideIdx, q.box, q.mode==='add'?'S':'C', qIndex));
    return wrap;
  }

  function buildGuide(q){
    const guide = el('div',{class:'guide', hidden:true});
    const title = el('div',{}, el('strong',{}, 'How to find the missing digit'));
    const line = el('div',{class:'meta'});

    let identity='', note='';
    if(q.mode==='add'){
      if(q.box==='A'){ identity = 'A = S − B'; note='Subtract B from S (column subtraction).'; }
      else if(q.box==='B'){ identity = 'B = S − A'; note='Subtract A from S (column subtraction).'; }
      else { identity = 'S = A + B'; note='Add A and B (column addition with carries).'; }
    }else{
      if(q.box==='A'){ identity = 'A = B + C'; note='Add B and C (column addition with carries).'; }
      else if(q.box==='B'){ identity = 'B = A − C'; note='Subtract C from A (column subtraction).'; }
      else { identity = 'C = A − B'; note='Subtract B from A (column subtraction).'; }
    }
    const place = ['thousands','hundreds','tens','ones'][q.hideIdx];
    line.textContent = `Use ${identity}. ${note} The boxed digit is the ${place} digit of the result.`;

    const mini = el('div',{class:'mini'});
    const mkMiniRow = (prefix, arr, hlIdx) => {
      const r = el('div',{class:'row'});
      r.appendChild(el('div',{class:'prefix'}, prefix));
      const dwrap = el('div',{class:'digits'});
      arr.forEach((d,i)=>{
        const cell = el('div',{class:'digit'}, d);
        if(i===hlIdx) cell.classList.add('hl');
        dwrap.appendChild(cell);
      });
      r.appendChild(dwrap);
      return r;
    };

    if(q.mode==='add' && q.box==='S'){
      mini.appendChild(mkMiniRow('', toDigits(q.A), -1));
      mini.appendChild(mkMiniRow('+', toDigits(q.B), -1));
      mini.appendChild(el('div',{class:'hr'}));
      mini.appendChild(mkMiniRow('', toDigits(q.S), q.hideIdx));
    } else if(q.mode==='add' && q.box==='A'){
      mini.appendChild(mkMiniRow('', toDigits(q.S), -1));
      mini.appendChild(mkMiniRow('−', toDigits(q.B), -1));
      mini.appendChild(el('div',{class:'hr'}));
      mini.appendChild(mkMiniRow('', toDigits(q.A), q.hideIdx));
    } else if(q.mode==='add' && q.box==='B'){
      mini.appendChild(mkMiniRow('', toDigits(q.S), -1));
      mini.appendChild(mkMiniRow('−', toDigits(q.A), -1));
      mini.appendChild(el('div',{class:'hr'}));
      mini.appendChild(mkMiniRow('', toDigits(q.B), q.hideIdx));
    } else if(q.mode==='sub' && q.box==='A'){
      mini.appendChild(mkMiniRow('', toDigits(q.B), -1));
      mini.appendChild(mkMiniRow('+', toDigits(q.C), -1));
      mini.appendChild(el('div',{class:'hr'}));
      mini.appendChild(mkMiniRow('', toDigits(q.A), q.hideIdx));
    } else if(q.mode==='sub' && q.box==='B'){
      mini.appendChild(mkMiniRow('', toDigits(q.A), -1));
      mini.appendChild(mkMiniRow('−', toDigits(q.C), -1));
      mini.appendChild(el('div',{class:'hr'}));
      mini.appendChild(mkMiniRow('', toDigits(q.B), q.hideIdx));
    } else {
      mini.appendChild(mkMiniRow('', toDigits(q.A), -1));
      mini.appendChild(mkMiniRow('−', toDigits(q.B), -1));
      mini.appendChild(el('div',{class:'hr'}));
      mini.appendChild(mkMiniRow('', toDigits(q.C), q.hideIdx));
    }

    guide.appendChild(title);
    guide.appendChild(line);
    guide.appendChild(mini);
    return guide;
  }

  function renderQuestion(q, idx){
    const card = el('div',{class:'qcard'});
    const header = el('div',{class:'header'},
      el('div',{}, el('span',{class:'qno'}, `Q${q.id}. `),
        el('span',{class:'tag'}, labelFor(q))),
      el('div',{class:'tag'}, q.mode==='add'?'Addition':'Subtraction')
    );

    const block = verticalBlock(q, idx);
    const input = QDOM[idx]._pendingInput;
    QDOM[idx].input = input;

    const btnCheck = el('button',{class:'primary'}, q.locked ? 'Submitted ✓' : 'Check & Submit');
    btnCheck.disabled = q.locked;

    const btnGuide = el('button',{}, 'Show Guide');
    const status = el('div',{class:'status muted'}, q.locked ? (q.mark? 'Correct. 1 mark awarded.' : '') : 'Key in a digit (0–9) and press the button.');
    const guide = buildGuide(q);
    QDOM[idx].status = status;
    QDOM[idx].btnCheck = btnCheck;
    QDOM[idx].btnGuide = btnGuide;
    QDOM[idx].guide = guide;

    if(q.value) input.value = q.value;
    if(q.locked){
      input.disabled = true;
      if(q.mark){ input.classList.add('correct'); }
    }

    input.addEventListener('input', e=>{
      e.target.value = e.target.value.replace(/\D/g,'').slice(0,1);
      q.value = e.target.value;
      e.target.classList.remove('wrong','correct');
      setStatus(status,'','muted');
      saveState();
    });
    input.addEventListener('keydown', e=>{
      if(e.key==='Enter'){ e.preventDefault(); btnCheck.click(); }
    });

    applyGuidePolicyToOne(q, idx);

    btnGuide.addEventListener('click', ()=>{
      if(btnGuide.disabled) return;
      guide.hidden = !guide.hidden;
      btnGuide.textContent = guide.hidden ? 'Show Guide' : 'Hide Guide';
    });

    btnCheck.addEventListener('click', ()=>{
      if(q.locked) return;
      const v = (input.value || '').trim();
      if(v===''){
        setStatus(status, 'Please enter a digit 0–9.', 'bad');
        input.classList.add('wrong'); input.focus(); return;
      }
      if(+v === q.hiddenDigit){
        q.mark = 1; q.locked = true;
        input.classList.remove('wrong'); input.classList.add('correct'); input.disabled = true;
        setStatus(status, 'Correct! +1 mark.', 'ok');
        btnCheck.disabled = true; btnCheck.textContent = 'Submitted ✓';
      }else{
        q.wrongOnce = true;
        input.classList.remove('correct'); input.classList.add('wrong');
        setStatus(status, 'Not quite. Try again — you may view the guide.', 'bad');
        if(WORK.policy==='locked' && btnGuide.disabled){
          btnGuide.disabled = false;
          btnGuide.title = '';
          guide.hidden = false;
          btnGuide.textContent = 'Hide Guide';
        }
      }
      saveState();
    });

    const actions = el('div',{class:'actions'}, btnCheck, btnGuide);
    card.appendChild(header);
    card.appendChild(block);
    card.appendChild(actions);
    card.appendChild(status);
    card.appendChild(guide);
    return card;
  }

  function setStatus(node, msg, kind){
    node.textContent = msg;
    node.className = 'status ' + (kind||'muted');
  }
  function labelFor(q){
    if(q.mode==='add'){
      return q.box==='A' ? 'Box in first addend'
           : q.box==='B' ? 'Box in second addend'
           : 'Box in sum';
    }else{
      return q.box==='A' ? 'Box in minuend'
           : q.box==='B' ? 'Box in subtrahend'
           : 'Box in difference';
    }
  }

  function applyGuidePolicyToOne(q, idx){
    const {btnGuide, guide} = QDOM[idx];
    if(WORK.policy === 'always'){
      btnGuide.disabled = false;
      btnGuide.title = '';
      btnGuide.textContent = 'Show Guide';
      guide.hidden = true;
    } else {
      const unlocked = q.wrongOnce || q.locked;
      btnGuide.disabled = !unlocked;
      btnGuide.title = unlocked ? '' : 'Guide will unlock after your first wrong attempt.';
      btnGuide.textContent = unlocked ? 'Show Guide' : 'Show Guide (locked)';
      guide.hidden = true;
    }
  }
  function applyPolicyAll(){
    WORK.questions.forEach((q,idx)=> applyGuidePolicyToOne(q, idx));
    if(WORK.policy==='always'){
      lockStateEl.textContent = 'Guides Unlocked (anytime)';
      lockStateEl.classList.remove('locked'); lockStateEl.classList.add('unlocked');
      btnUnlock.disabled = true; btnRelock.disabled = false;
    }else{
      lockStateEl.textContent = 'Guides Locked (until wrong)';
      lockStateEl.classList.remove('unlocked'); lockStateEl.classList.add('locked');
      btnUnlock.disabled = false; btnRelock.disabled = true;
    }
    saveState();
  }

  function updateScoreAndPush(){
    const total = WORK.questions.reduce((s,q)=>s+q.mark,0);
    scoreEl.textContent = `Score: ${total} / ${MDQ_TOTAL}`;
    const fb = buildFeedback(WORK);
    writePayload(total, fb);
    pushToXAPI(total, fb);
  }

  function mountAll(){
    partA.innerHTML = ''; partB.innerHTML = '';
    QDOM = Array.from({length:12}, ()=>({}));
    [0,1,2,3,4,5].forEach(i=> partA.appendChild(renderQuestion(WORK.questions[i], i)));
    [6,7,8,9,10,11].forEach(i=> partB.appendChild(renderQuestion(WORK.questions[i], i)));
    applyPolicyAll();
    // allow first paint to settle before enabling live pushes
    requestAnimationFrame(()=>{ BOOTING = false; updateScoreAndPush(); });
  }
  function rehydrateUIFromState(){ mountAll(); }

  // Teacher unlock/relock
  btnUnlock.addEventListener('click', ()=>{
    const pw = prompt('Teacher password required to unlock guides (4 digits):');
    if(pw === '0000'){ WORK.policy = 'always'; applyPolicyAll(); }
    else if(pw !== null){ alert('Incorrect password.'); }
  });
  btnRelock.addEventListener('click', ()=>{ WORK.policy = 'locked'; applyPolicyAll(); });

  // New session: clear saved state, regenerate, reset payload
  document.getElementById('newSessionBtn').addEventListener('click', ()=>{
    if(!confirm('Start a brand-new session? This clears saved progress and regenerates questions.')) return;
    try { localStorage.removeItem(STATE_KEY); } catch(e){}
    WORK = defaultWorksheet(); mountAll(); saveState();
    writePayload(0, ''); pushToXAPI(0, '');
  });

  // Boot: new-session clear kit (single init)
  window.addEventListener('load', ()=>{
    NewSessionClearKit.init({
      activityId: window.ACTIVITY_ID,
      clickButtonId: 'newSessionBtn',
      pushZero: false,
      onNewSession: () => {
        try { localStorage.removeItem(STATE_KEY); } catch(e){}
        writePayload(0, ''); pushToXAPI(0, '');
      }
    });
  }, { once:true });

  // Start
  (function init(){
    const saved = loadState();
    WORK = saved ? saved : defaultWorksheet();
    saveState();
    mountAll();
  })();

  function buildFeedback(work){
    const correct = work.questions.filter(q=>q.mark===1).map(q=>`Q${q.id}`);
    const wrong   = work.questions.filter(q=>q.mark===0 && q.locked).map(q=>`Q${q.id}`);
    const lines = [
      `Score ${correct.length}/${MDQ_TOTAL}`,
      `Correct: ${correct.length ? correct.join(', ') : '(none)'}`,
      `Incorrect: ${wrong.length ? wrong.join(', ') : '(none)'}`
    ];
    return lines.join(' | ');
  }
})();
</script>

</body>
</html>
